__author__ = "[Nancy Liddle]"
__email__ = "[nll2128@columbia.edu]"

#======================================================================#
#*#*#*# Optional: Import any allowed libraries you may need here #*#*#*#
#======================================================================#
import resource
import time
#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#

import argparse

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
	parser.add_argument('-bfs', action="store_true", default=False , help="Run BFS on the map")
	parser.add_argument('-dfs', action="store_true", default=False, help= "Run DFS on the map")
	parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
	parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
	parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
	parser.add_argument('-m', action="store", help="Map filename")

	results = parser.parse_args()

	if results.m=="" or not(results.all or results.astar or results.bfs or results.dfs or results.ida):
		print("Check the parameters : >> python hw1_UNI.py -h")
		exit()

	if results.all:
		results.bfs = results.dfs = results.astar = results.ida = True

	# Reading of map given and all other initializations
	try:
		with open(results.m) as f:
			arena = f.read()
			arena = arena.split("\n")
	except:
		print("Error in reading the arena file.")
		exit()

	# Internal representation
	print(arena)

	print("The arena of size "+ str(len(arena)) + "x" + str(len(arena[0])))
	print("\n".join(arena))

class MazeState:
	'''
	This class is an abstraction to store a maze state, which contains the following:
	- Maze configuration (arena)
	- Current Position (position in the maze that the current state represents)
	- Parent (the state from which the current state came from)
	- Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
	- Cost (Cost  of the path taken from the start to the current state)
	- Children (a child of the current state is generated by moving in a direction)
	'''
	
	def get_start_index(self):
		'''
		Returns the start index of the maze based on the given arena
		returns (-1, -1) if no start index found
		'''
		#=======================================================================#
		#*#*#*# TODO: Write your code to find the start index of the maze #*#*#*#
		#=======================================================================#
		for row in range(len(self.arena)):
			for column in range(len(self.arena[row])):
				if self.arena[row][column]=='s':
					return (row, column)
		return (-1, -1)
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def get_goal_index(self):
		'''
		Returns the goal index of the maze based on the given arena
		returns (-1, -1) if no goal index found
		'''
		#======================================================================#
		#*#*#*# TODO: Write your code to find the goal index of the maze #*#*#*#
		#======================================================================#
		for row in range(len(self.arena)):
			for column in range(len(self.arena[row])):
				if self.arena[row][column]=='g':
					return (row, column)
		return (-1, -1)
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1,-1)):

		self.arena = arena
		self.parent = parent
		self.action = action
		self.cost = cost
		self.children = []

		self.start = self.get_start_index()
		self.goal = self.get_goal_index()

		if(current_position[0] == -1):
			self.current_position = self.start
		else:
			self.current_position = current_position

	def display(self):
		print("\n".join(self.arena))

	def move_up(self):
		'''
		This function checks if up is a valid move from the given state.
		If up is a valid move, returns a child in which the player has moved up
		Else returns None.
		'''
		row, column = self.current_position[0], self.current_position[1]
		new_row, new_column= row-1, column
		if new_row<0:
			return None
		if self.arena[new_row][new_column]=="o" or self.arena[new_row][new_column]=="*":
			return None
		arena_new = [list(row_str) for row_str in self.arena]
		if arena_new[new_row][new_column] == ' ':
			arena_new[new_row][new_column] = '*'
		arena_new = [''.join(row_list) for row_list in arena_new]
		return MazeState(arena_new, self, 'Up', self.cost+1, (new_row, new_column))
		#=================================================================#
		#*#*#*# TODO: Write your code to move up in the puzzle here #*#*#*#
		#=================================================================#

		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_down(self):
		'''
		This function checks if down is a valid move from the given state.
		If down is a valid move, returns a child in which the player has moved down.
		Else returns None.
		'''
		
		#===================================================================#
		#*#*#*# TODO: Write your code to move down in the puzzle here #*#*#*#
		#===================================================================#

		row, column = self.current_position[0], self.current_position[1]
		new_row, new_column = row + 1, column
		if new_row >= len(self.arena):
			return None
		if self.arena[new_row][new_column] == "o" or self.arena[new_row][new_column]=="*":
			return None
		arena_new = [list(row_str) for row_str in self.arena]
		if arena_new[new_row][new_column] == ' ':
			arena_new[new_row][new_column] = '*'
		arena_new = [''.join(row_list) for row_list in arena_new]
		return MazeState(arena_new, self, 'Up', self.cost + 1, (new_row, new_column))
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def move_left(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		
		#===================================================================#
		#*#*#*# TODO: Write your code to move left in the puzzle here #*#*#*#
		#===================================================================#

		row, column = self.current_position[0], self.current_position[1]
		new_row, new_column = row, column - 1
		if new_column < 0:
			return None
		if self.arena[new_row][new_column] == "o" or self.arena[new_row][new_column]=="*":
			return None
		arena_new = [list(row_str) for row_str in self.arena]
		if arena_new[new_row][new_column] == ' ':
			arena_new[new_row][new_column] = '*'
		arena_new = [''.join(row_list) for row_list in arena_new]
		return MazeState(arena_new, self, 'Up', self.cost + 1, (new_row, new_column))
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_right(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		
		#====================================================================#
		#*#*#*# TODO: Write your code to move right in the puzzle here #*#*#*#
		#====================================================================#

		row, column = self.current_position[0], self.current_position[1]
		new_row, new_column = row, column + 1
		if new_column >= len(self.arena[0]):
			return None
		if self.arena[new_row][new_column] == "o" or self.arena[new_row][new_column]=="*":
			return None
		arena_new = [list(row_str) for row_str in self.arena]
		if arena_new[new_row][new_column] == ' ':
			arena_new[new_row][new_column] = '*'
		arena_new = [''.join(row_list) for row_list in arena_new]
		return MazeState(arena_new, self, 'Up', self.cost + 1, (new_row, new_column))
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def expand(self):
		""" 
		Generate the child nodes of this node 
		"""
		
		if(len(self.children) != 0):
			return self.children

		# Do not change the order in this function, since the grading script assumes this order of expansion when checking
		children = [self.move_up(), self.move_right(), self.move_down(), self.move_left()]

		self.children = [state for state in children if state is not None]
		return self.children
		
	def __hash__(self):
		'''
		Maze states hashed based on cost. 
		This function may be modified if required.
		'''
		return hash(self.current_position)
		#============================================================================================#
		#*#*#*# Optional: May be modified if your algorithm requires a different hash function #*#*#*#
		#============================================================================================#
		
		return self.cost
		
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#
		
	def __eq__(self, other):
		'''
		Maze states are defined as equal if they have the same dimensions and the same current position. 
		This function may be modified if required.
		'''
		if isinstance(other, MazeState):
			return self.current_position == other.current_position
		return False
	def __le__(self, other):
		if self.cost <= other.cost:
			return True
		else:
			return False
		
	def __lt__(self, other):
		if self.cost < other.cost:
			return True
		else:
			return False
		"""
		#=============================================================================================#
		#*#*#*# Optional: May be modified if your algorithm requires a different equality check #*#*#*#
		#=============================================================================================#
		"""
		m1 = self.arena
		m2 = other.arena

		if(len(m1) != len(m2)):
			return False

		for i in range(0, len(m1)):
			if(not (m1[i] == m2[i])):
				return False
				
		return self.current_position == other.current_position
		
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#
		
	#=====================================================================================#
	#*#*#*# Optional: Write any other functions you may need in the MazeState Class #*#*#*#
	#=====================================================================================#
	def path_finder(self, state, path):
		path.append(state.current_position)
		if state.current_position != self.get_start_index():
			return self.path_finder(state.parent, path)
		else:
			arena_temp = [list(row_str) for row_str in self.arena]
			for step in path:
				row, col = step
				if arena_temp[row][col] not in ['s', 'g']:
					arena_temp[row][col] = '*'
			final_arena = [''.join(row_list) for row_list in arena_temp]
			return final_arena
		
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#



#================================================================================#
#*#*#*# Optional: You may write helper functions in this space if required #*#*#*#
#================================================================================#
def manhattan_distance(position, goal):
	x1, y1 = position
	x2, y2 = goal
	return abs(x1 - x2) + abs(y1 - y2)
#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#


'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''
def bfs(arena):
	#=================================================#
	#*#*#*# TODO: Write your BFS algorithm here #*#*#*#
	#=================================================#
	start=time.time()
	start_mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
	start_mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
	frontier=[]
	expanded={}
	max_depth = 0
	ptr=0
	cur = MazeState(arena, None, 'Start', 0, (-1, -1))
	while cur.current_position != cur.get_goal_index():
		if cur not in expanded:
			expanded[cur]=MazeState.expand(cur)
		for state in expanded[cur]:
			if state not in frontier:
				max_depth = max(max_depth, state.cost)
				frontier.append(state)
		if ptr == len(frontier):
			break
		cur = frontier[ptr]
		ptr += 1
	return cur.path_finder(cur, []), cur.cost, len(expanded), len(frontier), max_depth, time.time()-start, (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss) - start_mem# Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''
def dfs(arena):

	#=================================================#
	#*#*#*# TODO: Write your DFS algorithm here #*#*#*#
	#=================================================#
	start = time.time()
	start_mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
	frontier = []
	expanded = {}
	max_depth = 0
	ptr = 0
	cur = MazeState(arena, None, 'Start', 0, (-1, -1))
	while cur.current_position != cur.get_goal_index():
		if cur not in expanded:
			expanded[cur] = reversed(MazeState.expand(cur))
		for state in expanded[cur]:
			if state not in frontier:
				max_depth = max(max_depth, state.cost)
				frontier.append(state)
		if ptr == len(frontier):
			break
		if frontier:
			cur=frontier.pop()
		else:
			break
	return cur.path_finder(cur, []), cur.cost, len(expanded), len(frontier)+len(expanded), max_depth, time.time() - start, (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss)-start_mem  # Replace with return values


# Replace with return values


#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''
def astar(arena):
	import heapq
	#================================================#
	#*#*#*# TODO: Write your A* algorithm here #*#*#*#
	#================================================#
	#Queues: [] i's children will be at index (left: 2i+1, right:2i+2)
	start = time.time()
	start_mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
	frontier = {}
	max_depth = 0
	expanded = set()
	cur = MazeState(arena, None, 'Start', 0, (-1, -1))
	while cur.current_position != cur.get_goal_index():
		if cur not in expanded:
			expanded.add(cur)
			exp= MazeState.expand(cur)
			for state in exp:
				max_depth = max(max_depth, state.cost)
				if state.cost not in frontier:
					frontier[state.cost]=[state]
				else:
					if state not in frontier[state.cost]:
						frontier[state.cost].append(state)

		if frontier:
			minKey=min(frontier, key=lambda k:frontier[k])
			cur = frontier[minKey].pop(0)
			if len(frontier[minKey])==0:
				del frontier[minKey]
		else:
			break
	return cur.path_finder(cur, []), cur.cost, len(expanded), len(frontier) + len(
		expanded)+1, max_depth, time.time() - start, (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss)-start_mem  # Replace with return values


# Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#
	
'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int, int, int, int, float, float) tuple where the [] represents the solved arena as a list of str 
and the numbers represent the other statistics to be returned
'''
def ida(arena):

	#=================================================#
	#*#*#*# TODO: Write your IDA algorithm here #*#*#*#
	#=================================================#
	dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
	start = time.time()
	start_state = MazeState(arena)
	goal_position = start_state.goal

	# Initial threshold is the heuristic estimate from the start node
	threshold = manhattan_distance(start_state.current_position, goal_position)

	# Stats variables
	nodes_expanded = 0
	max_nodes_stored = 0
	max_search_depth = 0

	# IDA* uses a path to keep track of the current path
	path = [start_state]

	def dfs(node, g, threshold):
		nonlocal nodes_expanded, max_nodes_stored, max_search_depth

		f = g + manhattan_distance(node.current_position, goal_position)
		if f > threshold:
			return f  # Return f-value to consider it for the next threshold

		if node.current_position == goal_position:
			return 'FOUND'

		nodes_expanded += 1

		if len(path) > max_search_depth:
			max_search_depth = len(path)

		min_threshold = float('inf')

		for child in node.expand():
			if child not in path:  # Avoid cycles
				path.append(child)
				if len(path) > max_nodes_stored:
					max_nodes_stored = len(path)
				t = dfs(child, g + 1, threshold)
				if t == 'FOUND':
					return 'FOUND'
				if t < min_threshold:
					min_threshold = t
				path.pop()
		return min_threshold

	while True:
		temp = dfs(start_state, 0, threshold)
		if temp == 'FOUND':
			# Goal found, reconstruct the path
			return_arena = [list(row) for row in arena]
			for state in path[1:-1]:
				i, j = state.current_position
				return_arena[i][j] = '*'
			return_arena = [''.join(row) for row in return_arena]
			running_time = time.time() - t
			dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram) / (2 ** 10)
			return (return_arena, len(path) - 1, nodes_expanded,
					max_nodes_stored, max_search_depth, running_time, dfs_ram)
		if temp == float('inf'):
			# No solution found
			return None
		threshold = temp

	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

if __name__ == "__main__":

	if results.bfs:
		print("\nBFS algorithm called")
		bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(arena)
		print("\n".join(bfs_arena))
		print("BFS:")
		print("Cost: " + str(bfs_cost))
		print("Nodes Expanded: " + str(bfs_nodes_expanded))
		print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
		print("Max Search Depth: " + str(bfs_max_search_depth))
		print("Time: " + str(bfs_time) + "s")
		print("RAM Usage: " + str(bfs_ram) + "kB\n")

	if results.dfs:
		print("\nDFS algorithm called")
		dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(arena)
		print("\n".join(dfs_arena))
		print("DFS:")
		print("Cost: " + str(dfs_cost))
		print("Nodes Expanded: " + str(dfs_nodes_expanded))
		print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
		print("Max Search Depth: " + str(dfs_max_search_depth))
		print("Time: " + str(dfs_time) + "s")
		print("RAM Usage: " + str(dfs_ram) + "kB\n")

	if results.astar:
		print("\nA* algorithm called")
		astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(arena)
		print("\n".join(astar_arena))
		print("A*:")
		print("Cost: " + str(astar_cost))
		print("Nodes Expanded: " + str(astar_nodes_expanded))
		print("Max Nodes Stored: " + str(astar_max_nodes_stored))
		print("Max Search Depth: " + str(astar_max_search_depth))
		print("Time: " + str(astar_time) + "s")
		print("RAM Usage: " + str(astar_ram) + "kB\n")
	
	if results.ida:
		print("\nIterative Deepening A* algorithm called")
		ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(arena)
		print("\n".join(ida_arena))
		print("Iterative Deepening A*:")
		print("Cost: " + str(ida_cost))
		print("Nodes Expanded: " + str(ida_nodes_expanded))
		print("Max Nodes Stored: " + str(ida_max_nodes_stored))
		print("Max Search Depth: " + str(ida_max_search_depth))
		print("Time: " + str(ida_time) + "s")
		print("RAM Usage: " + str(ida_ram) + "kB\n")
